{"./":{"url":"./","title":"Swift中的可选类型?和隐式解析可选类型!","keywords":"","body":"Swift中的可选类型?和隐式解析可选类型! Swift是一种类型安全的语言，可选类型的引入也让我们的编码变得更加安全。但是满屏的?和!也会让人很烦。于是我们有时候会使用隐式解析可选类型（implicitly unwrapped optionals）。本文将探讨如何正确使用这种类型。 可选类型? 开发中经常会需要处理变量值为空的情况，Swift作为一种类型安全的语言很重视值为空的情况。于是引入了可选类型。 可选类型的值可能有值，也可能为空值。所以必须要处理可能为空值nil时的情况 let possibleString: String? = \"Hello\" if let actualString = possibleString { // actualString是普通（非可选）字符串，其值与possibleString中的值相同 print(actualString) //输出\"Hello\\n\" } else { // possibleString为空值时的情况 } 可选类型的值是可选值，这在字符串类型中需要特别注意 let possibleString: String? = \"Hello\" print(possibleString) //编译器会提示“Expression implicitly coerced from 'String?' to Any”； // 此时打印出来的值是\"Optional(\"Hello\")\" 如上例所示，如果直接使用可选字符串，那么值将会包含在Optional(\"\")中。此时就需要使用强制解析符号! let possibleString: String? = \"Hello\" print(possibleString!) // \"Hello\\n\" 使用可选类型可以让代码更加严谨，并且在每个使用的地方强迫你去思考这里是否可能为空。 // 应用场景 // 错误写法: let url: URL = URL(string: \"http://www.baidu.com\") // 因为URL的构造函数可能会失败，所以它的返回值是URL?类型 // 正确写法: let url: URL? = URL(string: \"http://www.baidu.com\") // 使用类型推导 let url = URL(string: \"http://www.baidu.com\") /* 不推荐写法 if url != nil { URLRequest(url: url!) } */ // 该语法称为可选绑定（如果url有值就解包赋值给tempUrl，并执行{}） if let tempUrl = url { URLRequest(url: tempUrl) } 隐式解析可选类型 如上所示，可选类型在使用中需要判断是否为空值，那么这就带来一个问题：怎么确定一个可选类型是有值的呢？ 比如像这样 var dog: String? = \"wangcai\" let cat: String = dog // Error: Value of optional type 'String?' not unwrapped; did you mean to use '!' or '?'? 如上，变量cat在接受赋值时无法确定dog是不是nil，因为它是可选类型，所以编译器报错。 所以，就像上文所说使用强制解析!来表示我有值。或者cat也声明为可选类型 var dog: String? = \"wangcai\" let cat: String? = dog 为了省心，我们使用强制解析!，但是以下情况就不省心了 var dog: String? = \"wangcai\" //dog变量想要给一个非可选类型的cat变量赋值 let cat: String = dog! //cat说，嗯，我已经拿到啦，么么哒！ let tiger: String = dog! //hello，我是旺财～ let fish: String = dog! //我是旺财～ let bird: String = dog! //旺财。。。 let sheep: String = dog! //为什么每次都得验证一遍 let mouse: String = dog! //心好累 为了不出现满屏的!，我们可以采用隐式解析可选类型 var dog: String! = \"wangcai\" //dog变量想要给一个非可选类型的cat变量赋值 let cat: String = dog //cat说，嗯，我已经拿到啦，么么哒！ let tiger: String = dog //ok let fish: String = dog //ok let bird: String = dog //ok let sheep: String = dog //ok let mouse: String = dog //ok 看，将dog声明为隐式解析可选类型String!省去了满世界的!。 那么我们是否一直使用隐式解析可选类型就万事大吉了呢？答案是No。因为隐式解析可选类型还是可选类型，它是可以为空的。如果在空值时被使用，程序就会Crash。 var url: URL! = URL(string: \"www.baidu.com\") url = nil // nothing happened URLRequest(url: url) // fatal error: unexpectedly found nil while unwrapping an Optional value 什么时候使用隐式解析可选类型？ 1、初始化过程中不能定义的常量 每一个成员常量在初始化完成后一定会有一个值。然而有的时候在初始化过程中不能确定会有正确的值，但是又可以确保在被访问前一定会有值。使用可选变量不会有问题，因为可选变量在初始化时会自动被赋予nil，并且在初始化结束时被赋予正确的值。但是使用时的强制解包会很痛苦，满屏幕都会是!。以下展示了一个成员变量在视图加载完成之前不能完成初始化的例子： class MyController: UIViewController { @IBOutlet var button: UIButton! var buttonOriginalWidth: CGFloat! override func viewDidLoad() { self.buttonOriginalWidth = self.button.frame.size.width } } 这里有2个隐式解析可选类型。IBOutlet类型是Xcode强制为可选类型的，因为它不是在初始化时赋值的，而是在加载视图的时候。你可以把它设置为普通可选类型，但是如果这个视图加载正确，它是不会为空的。在视图加载完成之前，我们无法知道button的初始宽度。但是我们知道viewDidLoad方法会在任何方法之前被调用（除了初始化函数）。与其在所有地方强制解包，不如定义成隐式解析可选类型。 2、当程序不能在某个变量为nil后恢复 这种情况非常罕见。如果应用程序在访问某个空的变量时无法继续运行，那么也就无需再判空了。通常情况下，如果程序必须符合某个条件才能继续运行，则可以使用断言。 什么时候不使用隐式解析可选类型？ 1、延迟加载计算类型成员 有时候我们需要永远不为空的成员变量，但是它可能在初始化时不能被正确赋值。一种方法是使用隐式解析可选类型。不过更好的方法是使用延迟加载： class FileSystemItem { } class Directory: FileSystemItem { lazy var contents: [FileSystemItem] = { var loadedContents = [FileSystemItem]() // load contents and append to loadedContents return loadedContents }() } 如上代码所示，contents不会被初始化直到它第一次被访问。 2、另外任何地方 在大多数情况下，要避免使用隐式解析可选类型，因为一旦使用错误就会造成程序Crash。如果不确定一个变量是否会是nil，就默认使用普通可选类型。去解包一个不会是nil的变量不会有什么副作用。 参考 Swift中的可选类型?和隐式解析可选类型! Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-12 15:24:04 "},"content/iOS/Swiftif-let&guard-let.html":{"url":"content/iOS/Swiftif-let&guard-let.html","title":"Swift if-let & guard-let","keywords":"","body":"Swift if-let & guard-let 1、if let用法 1.1 普通if与if let的比较 1、 如果常量是可选项（Optional），if判断后仍然需要解包（!） let name: String? = \"老王\" let age: Int? = 10 if name != nil && age != nil { print(name! + String(age!)) // 输出:老王10 } 2、如果常量是可选项（Optional），if let判断后不需要解包（!），{ }内一定有值 let name: String? = \"老王\" let age: Int? = 10 // if let 连用,判断对象的值是否为'nil' if let nameNew = name, let ageNew = age { // 进入分支后,nameNew 和 ageNew 一定有值 print(nameNew + String(ageNew)) // 输出:老王10 } Tips：nameNew和 ageNew的作用域仅在{}中 2、guard let用法 1、guard let和if let刚好相反，guard let守护一定有值。如果没有，直接返回。 2、通常判断是否有值之后，会做具体的逻辑实现，通常代码多 3、如果用 if let凭空多了一层分支，guard let是降低分支层次的办法 4、guard let语法是 Swift 2.0 推出的 let name: String? = \"老王\" let age: Int? = 10 guard let nameNew = name, let ageNew = age else { print(\"姓名 或 年龄 为nil\") return } // 代码执行至此, nameNew 和 ageNew 一定有值 print(nameNew + String(ageNew)) // 输出:老王10 3、 if let和guard let的命名技巧 技巧：取和参数名相同的变量名 1、guard let演示 override func viewDidLoad() { super.viewDidLoad() demo(name: \"老王\", age: 11) } func demo(name: String?, age: Int?) { guard let name = name, let age = age else { print(\"姓名或年龄为nil\") return } /** * 'name'至此会有两个 * 1.String name('guard let'守护,等号右边的'name') * 2.String? name('guard let'守护,等号右边的'name') * 3.这里正常应该选择不带'?'的'name',但是即便是选择了('Optional'的'name'),编译器也会帮你更正过来,这就是取名的技巧 */ print(name + String(age)) // 输出:老王11('name'和'age'为不带'Optional'的) } 2、if let演示 override func viewDidLoad() { super.viewDidLoad() demo(name: \"老王\", age: 11) } func demo(name: String?, age: Int?) { if let name = name, let age = age { /** * 'name'至此只会有两个 * 1.String name('if let'守护,等号右边的'name',仅在'{}'作用域内有效) * 2.String? name('if let'守护,等号右边的'name') * 3.这里正常应该选择不带'?'的'name',但是即便是选择了('Optional'的'name'),编译器也会帮你更正过来,这就是取名的技巧 * 4.如果'name'或'age'中有一个为'nil',或者都为'nil',下面就不会输出 */ print(name + String(age)) // 输出:老王11('name'和'age'为不带'Optional'的) } /** * 'name'至此只会有一个 * 2.String? name(demo(name: String?)中的'name') * 3.这里正常应该选择不带'?'的'name',但是即便是选择了('Optional'的'name'),编译器也会帮你更正过来,这就是取名的技巧 */ print(\"demo(name: String?)中的'name'\") } 4、参考 Swift 基本语法03-\"if let\"和\"guard let\" Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-12 16:10:19 "},"content/iOS/SwiftTips.html":{"url":"content/iOS/SwiftTips.html","title":"SwiftTips","keywords":"","body":"Swift Tips 一、 as、as!、as? 三种类型转换操作符的异同，以及各自的使用场景 1、as使用场合 （1）从派生类转换为基类，向上转型（upcasts） class Animal {} class Cat: Animal {} let cat = Cat() let animal = cat as Animal （2）消除二义性，数值类型转换 let num1 = 42 as CGFloat let num2 = 42 as Int let num3 = 42.5 as Int let num4 = (42 / 2) as Double （3）switch 语句中进行模式匹配如果不知道一个对象是什么类型，你可以通过switch语法检测它的类型，并且尝试在不同的情况下使用对应的类型进行相应的处理。 switch animal { case let cat as Cat: print(\"如果是Cat类型对象，则做相应处理\") case let dog as Dog: print(\"如果是Dog类型对象，则做相应处理\") default: break } 2、as!使用场合 向下转型（Downcasting）时使用。由于是强制类型转换，如果转换失败会报 runtime 运行错误。 class Animal {} class Cat: Animal {} let animal :Animal = Cat() let cat = animal as! Cat 3、as?使用场合 as? 和 as! 操作符的转换规则完全一样。但 as? 如果转换不成功的时候便会返回一个 nil 对象。成功的话返回可选类型值（optional），需要我们拆包使用。由于 as? 在转换失败的时候也不会出现错误，所以对于如果能确保100%会成功的转换则可使用 as!，否则使用 as? let animal:Animal = Cat() if let cat = animal as? Cat{ print(\"cat is not nil\") } else { print(\"cat is nil\") } Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-12 14:33:25 "},"content/Mac/Homebrew.html":{"url":"content/Mac/Homebrew.html","title":"Homebrew","keywords":"","body":"Homebrew 安装 在安装 Homebrew 之前，需要将 Xcode Command Line Tools 安装完成，这样你就可以使用基于 Xcode Command Line Tools 编译的 Homebrew。在 Terminal 中复制以下命令（不包括 $），跟随指引，将完成 Hombrew 安装。 $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 紧接着，我们需要做一件事让通过 Homebrew 安装的程序的启动链接 (在 /usr/local/bin中）可以直接运行，无需将完整路径写出。通过以下命令将 /usr/local/bin 添加至 $PATH 环境变量中: $ echo 'export PATH=\"/usr/local/bin:$PATH\"' >> ~/.bash_profile Cmd+T 打开一个新的 terminal 标签页，运行以下命令，确保 brew 运行正常。 $ brew -v 更换源 替换brew.git: cd \"$(brew --repo)\" git remote set-url origin https://mirrors.ustc.edu.cn/brew.git 替换homebrew-core.git: cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 常用命令 1.安装卸载软件 1. brew --version或者brew -v 显示brew版本信息 2. brew install 安装指定软件 3. brew unistall 卸载指定软件 4. brew list 显示所有的已安装的软件 5. brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 6. brew search /text/ 使用正则表达式搜软件 2.升级软件相关 1. brew update 自动升级homebrew（从github下载最新版本） 2. brew outdated 检测已经过时的软件 3. brew upgrade 升级所有已过时的软件，即列出的以过时软件 4. brew upgrade 升级指定的软件 5. brew pin 禁止指定软件升级 6. brew unpin 解锁禁止升级 7. brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 3.清理相关 homebrew再升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理 1. brew cleanup -n 列出需要清理的内容 2. brew cleanup 清理指定的软件过时包 3. brew cleanup 清理所有的过时软件 4. brew unistall 卸载指定软件 5. brew unistall --force 彻底卸载指定软件，包括旧版本 通过brew安装的文件会自动设置环境变量，所以不用担心命令行不能启动的问题。 4.参考 Homebrew官网 HomeBrew常规使用教程 关于macOS的目录和软件安装 Brew 的工作细节 5.问题记录 `usr/bin occurs before /usr/local/bin` //打开paths vim /etc/paths /*and add /usr/local/bin and /usr/local/sbin like this*/ /usr/local/bin /usr/local/sbin /usr/bin /bin /usr/sbin /sbin /*重新打开一个终端窗口*/ env|grep PATH 输出：PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:14:02 "},"content/ReactNative/ReactNative常用命令.html":{"url":"content/ReactNative/ReactNative常用命令.html","title":"ReactNative常用命令","keywords":"","body":"ReactNative常用命令 1、创建项目 //默认使用最新的RN版本创建 react-native init MyApp //指定具体的RN版本 react-native init MyApp --version 0.44.0 2、安装/卸载指定的库(--save 记录到package.json) //安装所有的库 npm install //安装具体的库 npm install xxxlib --save //卸载 npm uninstall xxxlib --save 3、升级指定的第三方库 //1、在项目根目录（package.json同级目录）查看过期的npm包 npm outdated //2、在package.json文件里找到需要升级的库，修改为需要的版本号 //3、执行 npm update xxxxlib //4、升级完成后，重新开启server并重置缓存 npm start -- --reset-cache 4、link库文件 //link所有的库 react-native link //link指定的库 react-native link xxxxlib 5、启动npm服务 //iOS //默认启动iPhone6模拟器 react-native run-ios //指定具体的模拟器 react-native run-ios --simulator \"iPhone X\" react-native run-ios --simulator \"iPhone 8\" //Android react-native run-android Tips：终端查看/启动iOS模拟器 //模拟器列表 xcrun instruments -s //启动模拟器 xcrun instruments -w \"iPhone XS Max (12.0) [BFAC9D75-39B7-4885-B34E-6CEB4D31D448]\" 6、Clearing the Cache of your React Native Project: RN >= 0.50 watchman watch-del-all && rm -rf $TMPDIR/react-native-packager-cache-* && rm -rf $TMPDIR/metro-bundler-cache-* && rm -rf node_modules/ && npm cache clean && npm install && npm start -- --reset-cache RN watchman watch-del-all && rm -rf $TMPDIR/react-* && rm -rf node_modules/ && npm cache clean && npm install && npm start -- --reset-cache 7、离线包资源整合 //iOS //在RN工程的根目录下先创建release_ios文件夹，然后执行如下命令，main.jsbundle及assert资源文件夹打包完成之后，添加到iOS工程的根目录下，然后正常run及archiver，就会自动读取app包里面的js文件。 react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ //Android //首先在：android/app/src/main/ 目录下创建 assets 目录 react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/ Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:12:46 "},"content/ReactNative/ReactNative集成到原生项目.html":{"url":"content/ReactNative/ReactNative集成到原生项目.html","title":"ReactNative集成到原生项目","keywords":"","body":"ReactNative集成至现有原生项目 一、准备 1、 创建 /ios目录，并拷贝iOS原生项目的所有工程文件到该目录下； 2、 创建/android目录，并拷贝Android原生项目的所有工程文件到该目录下； 3、 在根目录下创建package.json文件，并添加如下内容； { \"name\": \"MyReactNativeApp\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": { \"start\": \"node node_modules/react-native/local-cli/cli.js start\" } } 4、 根目录下执行 yarn add react-native 或者`npm i --save react-native`` 5、 安装与当前react-native版本配套的react 可以根据步骤四中输出的警告信息查看，具体版本如：warning \"react-native@0.57.6\" has unmet peer dependency \"react@16.6.1\". 或者直接查看react-native的package.json中依赖react的版本package.json yarn add react@16.6.1 或 `npm i --save react@16.6.1`` 6、 工程目录 二、iOS集成 注意：此处默认本机cocoapods已安装完成，未安装的可先google对应教程安装。参考：CocoaPods安装方法 1、 在\\ios根目录下，终端执行pod init，生成Podfile文件； 2、 编辑Podfile文件，可参考如下配置： # Uncomment the next line to define a global platform for your project platform :ios, '9.0' target 'MyReactNativeApp' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for MyReactNativeApp # 'node_modules'目录一般位于根目录中 # 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path` pod 'React', :path => '../node_modules/react-native', :subspecs => [ 'Core', 'CxxBridge', # 如果RN版本 >= 0.47则加入此行 'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 调试功能需要此模块 'RCTAnimation', # FlatList和原生动画功能需要此模块 # 在这里继续添加你所需要的其他RN模块 'RCTActionSheet', 'RCTBlob', 'RCTGeolocation', 'RCTImage', 'RCTSettings', 'RCTVibration', 'RCTLinkingIOS', ] # 如果你的RN版本 >= 0.42.0，则加入下面这行 pod 'yoga', :path => '../node_modules/react-native/ReactCommon/yoga' # 如果RN版本 >= 0.45则加入下面三个第三方编译依赖 pod 'DoubleConversion', :podspec => '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec => '../node_modules/react-native/third-party-podspecs/glog.podspec' pod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec' target 'MyReactNativeAppTests' do inherit! :search_paths # Pods for testing end target 'MyReactNativeAppUITests' do inherit! :search_paths # Pods for testing end end 3、 执行pod install； 4、 工程根目录下创建index.js import React, {Component} from 'react'; import { AppRegistry, StyleSheet, View, Text, } from 'react-native'; class index extends Component { render() { return ( 我是ReactNative ! ); } } const styles = StyleSheet.create({ container:{ flex:1, backgroundColor:'green', justifyContent:'center', alignItems:'center' } }); AppRegistry.registerComponent(\"MyReactNativeApp\", () => index); 5、 在原生项目中测试： 在需要跳转的ViewController： #import #import - (void)pushToReactNativeVc { NSURL *jsBundleLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsBundleLocation moduleName:@\"MyReactNativeApp\" initialProperties:nil launchOptions:nil]; UIViewController *vc = [[UIViewController alloc] init]; vc.view = rootView; [self.navigationController pushViewController:vc animated:YES]; } Tips：如果遇到 如下错误 打开Build Phases→Link Binary With Libraries点击 + ,然后添加如下的.a静态库 三、Android集成 3.1 配置Gradle 1、Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。Maven的核心功能便是合理叙述项目间的依赖关系，通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包； 2、Gradle抛弃了传统基于XML（如Ant和Maven）的各种繁琐配置，使用了基于Groovy的领域特定语言（DSL）来声明项目配置。 3、Gradle兼容Maven仓库。 3.1.1 在app 中 build.gradle 文件中添加 React Native 依赖 dependencies { implementation 'com.android.support:appcompat-v7:23.0.1' ... implementation \"com.facebook.react:react-native:+\" // From node_modules } 如果想要指定特定的 React Native 版本，可以用具体的版本号替换 +，当然前提是你从 npm 里下载的是这个版本。 3.1.2 在项目的 build.gradle 文件中为 React Native 添加一个 maven 依赖的入口，必须写在 \"allprojects\" 代码块中: allprojects { repositories { maven { // All of React Native (JS, Android binaries) is installed from npm url \"$rootDir/../node_modules/react-native/android\" } ... } ... } 确保依赖路径的正确！以免在 Android Studio 运行 Gradle 同步构建时抛出 “Failed to resolve: com.facebook.react:react-native:0.x.x\" 异常。 3.2 配置权限 3.2.1 在 AndroidManifest.xml 清单文件中声明网络权限: 3.2.2 如果需要访问 DevSettingsActivity 界面（即开发者菜单），则还需要在 AndroidManifest.xml 中声明: 3.2.3 修改abiFilters ndk { abiFilters \"armeabi-v7a\", \"x86\" } 原因 react-native生成aar的源码在npm install命令下载生成的 '$项目根目录'\\node_modules\\react-native\\ReactAndroid中； aar中关于对于CPU限制在 '$项目根目录'\\node_modules\\react-native\\ReactAndroid\\src\\main\\jni\\Application.mk , 在这个文件中，我们可以到： APP_BUILD_SCRIPT := Android.mk APP_ABI := armeabi-v7a x86 APP_PLATFORM := android-16 APP_MK_DIR := $(dir $(lastword $(MAKEFILE_LIST))) NDK_MODULE_PATH := $(APP_MK_DIR)$(HOST_DIRSEP)$(THIRD_PARTY_NDK_DIR)$(HOST_DIRSEP)$(REACT_COMMON_DIR)$(HOST_DIRSEP)$(APP_MK_DIR)first-party APP_STL := gnustl_shared # Make sure every shared lib includes a .note.gnu.build-id header APP_CFLAGS := -Wall -Werror APP_CPPFLAGS := -std=c++1y APP_LDFLAGS := -Wl,--build-id NDK_TOOLCHAIN_VERSION := 4.9 说明了CPU的类型限定在了armeabi-v7a和x86上 3.3 加载ReactNative视图 方式一、继承ReactActivity 需要使用RN的页面继承ReactActivity import com.facebook.react.ReactActivity; public class MainActivity extends ReactActivity { /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() { return \"MyReactNativeApp\"; } } Application中实现ReactApplication的方法，如下： @Override public ReactNativeHost getReactNativeHost() { return reactNativeHost; } private final ReactNativeHost reactNativeHost = new ReactNativeHost(this) { @Override public boolean getUseDeveloperSupport() { return BuildConfig.DEBUG; } @Override protected List getPackages() { return Arrays.asList( new MainReactPackage() ); } @Override protected String getJSMainModuleName(){ return \"index\"; } }; 方式二、在布局中加入ReactRootView，通过 ReactInstanceManager加载管理JS 1、配置权限以便开发中的红屏错误能正确显示 如果你的应用会运行在 Android 6.0（API level 23）或更高版本，请确保你在开发版本中有打开悬浮窗(overlay)权限。你可以在代码中使用Settings.canDrawOverlays(this);来检查。之所以需要这一权限，是因为我们会把开发中的报错显示在悬浮窗中（仅在开发阶段需要）。在 Android 6.0（API level 23）中用户需要手动同意授权。具体请求授权的做法是在onCreate()中添加如下代码。其中OVERLAY_PERMISSION_REQ_CODE是用于回传授权结果的字段。 private final int OVERLAY_PERMISSION_REQ_CODE = 1; // 任写一个值 ... if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { if (!Settings.canDrawOverlays(this)) { Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(\"package:\" + getPackageName())); startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE); } } 重写onActivityResult()方法 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (requestCode == OVERLAY_PERMISSION_REQ_CODE) { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { if (!Settings.canDrawOverlays(this)) { // SYSTEM_ALERT_WINDOW permission not granted } } } } 接下来添加一些原生代码来启动 React Native 的运行时环境并让它开始渲染。首先需要在一个Activity中创建一个ReactRootView对象，然后在这个对象之中启动 React Native 应用，并将它设为界面的主视图。 如果你想在安卓 5.0 以下的系统上运行，请用 com.android.support:appcompat 包中的 AppCompatActivity 代替 Activity 。 public class MyReactActivity extends Activity implements DefaultHardwareBackBtnHandler { private ReactRootView mReactRootView; private ReactInstanceManager mReactInstanceManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mReactRootView = new ReactRootView(this); mReactInstanceManager = ReactInstanceManager.builder() .setApplication(getApplication()) .setBundleAssetName(\"index.android.bundle\") .setJSMainModulePath(\"index\") .addPackage(new MainReactPackage()) .setUseDeveloperSupport(BuildConfig.DEBUG) .setInitialLifecycleState(LifecycleState.RESUMED) .build(); // 注意这里的MyReactNativeApp必须对应“index.js”中的 // “AppRegistry.registerComponent()”的第一个参数 mReactRootView.startReactApplication(mReactInstanceManager, \"MyReactNativeApp\", null); setContentView(mReactRootView); } @Override public void invokeDefaultOnBackPressed() { super.onBackPressed(); } @Override public void onBackPressed() { if (mReactInstanceManager != null) { mReactInstanceManager.onBackPressed(); } else { super.onBackPressed(); } } } 生命周期 @Override protected void onPause() { super.onPause(); if (mReactInstanceManager != null) { mReactInstanceManager.onHostPause(this); } } @Override protected void onResume() { super.onResume(); if (mReactInstanceManager != null) { mReactInstanceManager.onHostResume(this, this); } } @Override protected void onDestroy() { super.onDestroy(); if (mReactInstanceManager != null) { mReactInstanceManager.onHostDestroy(this); } if (mReactRootView != null) { mReactRootView.unmountReactApplication(); } } 弹出RN的开发者菜单 @Override public boolean onKeyUp(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_MENU && mReactInstanceManager != null) { mReactInstanceManager.showDevOptionsDialog(); return true; } return super.onKeyUp(keyCode, event); } 3.4 Android相关报错处理 1、so库冲突 处理：在app下的build.gride中添加如下设置 packagingOptions { pickFirst 'lib/x86/libgnustl_shared.so' pickFirst 'lib/armeabi-v7a/libgnustl_shared.so' } Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:13:13 "},"content/ReactNative/ReactNative与iOS的交互.html":{"url":"content/ReactNative/ReactNative与iOS的交互.html","title":"ReactNative与iOS的交互","keywords":"","body":"ReactNative与iOS的交互 1.1 RCTRootView初始化问题 /** * - Designated initializer - */ - (instancetype)initWithBridge:(RCTBridge *)bridge moduleName:(NSString *)moduleName initialProperties:(NSDictionary *)initialProperties NS_DESIGNATED_INITIALIZER; /** * - Convenience initializer - * A bridge will be created internally. * This initializer is intended to be used when the app has a single RCTRootView, * otherwise create an `RCTBridge` and pass it in via `initWithBridge:moduleName:` * to all the instances. */ - (instancetype)initWithBundleURL:(NSURL *)bundleURL moduleName:(NSString *)moduleName initialProperties:(NSDictionary *)initialProperties launchOptions:(NSDictionary *)launchOptions; 1、当Native APP内只有一处RN的入口时，可以使用initWithBundleURL，否则的话就要使用initWithBridge方法。 2、因为initWithBundleURL会在内部创建一个RCTBridge，当有多个RCTRootView入口时，就会存在多个RCTBridge，容易导致Native端与RN交互时多次响应，出现BUG。 1.2 创建自定义的RNBridgeManager 由于APP内有RN多入口的需求，所以共用一个RCTBridge RNBridgeManager.h #import #import NS_ASSUME_NONNULL_BEGIN @interface RNBridgeManager : RCTBridge /** RNBridgeManager单例 */ + (instancetype)sharedManager; @end NS_ASSUME_NONNULL_END RNBridgeManager.m #import \"RNBridgeManager.h\" #import //dev模式下:RCTBridge required dispatch_sync to load RCTDevLoadingView Error Fix #if RCT_DEV #import #endif /** 自定义类，实现RCTBridgeDelegate */ @interface BridgeHandle : NSObject @end @implementation BridgeHandle - (NSURL *)sourceURLForBridge:(RCTBridge *)bridge{ return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil]; } @end @implementation RNBridgeManager + (instancetype)sharedManager{ static RNBridgeManager *manager; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ manager = [[RNBridgeManager alloc] initWithDelegate:[[BridgeHandle alloc] init] launchOptions:nil]; #if RCT_DEV [manager moduleForClass:[RCTDevLoadingView class]]; #endif }); return manager; } @end 1.3 Native进入RN页面 RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:[RNBridgeManager sharedManager] moduleName:@\"RNTest\" initialProperties:nil]; UIViewController *vc = [[UIViewController alloc] init]; vc.view = rootView; [self.navigationController pushViewController:vc animated:YES]; 1.4 RN调用Native方法 创建一个交互的类，实现协议； 固定格式：在.m的实现中，首先导出模块名字RCT_EXPORT_MODULE();，RCT_EXPORT_MODULE接受字符串作为其Module的名称，如果不设置名称的话默认就使用类名作为Modul的名称； 使用RCT_EXPORT_METHOD导出Native的方法； 1.4.1 比如我们导出Native端的SVProgressHUD提示方法： RNInterractModule.h #import #import NS_ASSUME_NONNULL_BEGIN @interface RNInterractModule : NSObject @end NS_ASSUME_NONNULL_END RNInterractModule.m import \"RNInterractModule.h\" #import \"Util.h\" #import @implementation RNInterractModule ////RCT_EXPORT_MODULE接受字符串作为其Module的名称，如果不设置名称的话默认就使用类名作为Modul的名称 RCT_EXPORT_MODULE(); //==============1、提示============== RCT_EXPORT_METHOD(showInfo:(NSString *) info){ dispatch_sync(dispatch_get_main_queue(), ^{ [SVProgressHUD showInfoWithStatus:info]; }); } @end 1.4.2 RN端调用导出的showInfo方法： 我们在RN端把Native的方法通过一个共同的utils工具类引入，如下 import { NativeModules } from 'react-native'; //导出Native端的方法 export const { showInfo} = NativeModules.RNInterractModule; 具体的RN页面使用时： import { showInfo } from \"../utils\"; //通过Button点击事件触发 showInfo('我是原生端的提示！')} /> 调用效果： 1.4.3 RN回调Native RN文档显示，目前iOS端的回调还处于实验阶段 我们提供一个例子来模拟：目前的需求是做面包，RN端能提供面粉，但是不会做，Native端是有做面包的功能；所以我们需要先把面粉，传给Native端，Native加工好面包之后，再通过回调回传给RN端。 Native端提供方法 // 比如调用原生的方法处理图片、视频之类的，处理完成之后再把结果回传到RN页面里去 //TODO（RN文档显示，目前iOS端的回调还处于实验阶段） RCT_EXPORT_METHOD(patCake:(NSString *)flour successBlock:(RCTResponseSenderBlock)successBlock errorBlock:(RCTResponseErrorBlock)errorBlock){ __weak __typeof(self)weakSelf = self; dispatch_sync(dispatch_get_main_queue(), ^{ NSString *cake = [weakSelf patCake:flour]; //模拟成功、失败的block判断 if([flour isKindOfClass:[NSString class]]){ successBlock(@[@[cake]]);//此处参数需要放在数组里面 }else{ NSError *error = [NSError errorWithDomain:@\"com.RNTest\" code:-1 userInfo:@{@\"message\":@\"类型不匹配\"}]; errorBlock(error); } }); } //使用RN端传递的参数字符串：\"\"，调用Native端的做面包方法，加工成面包，再回传给RN - (NSString *)patCake:(NSString *)flour{ NSString * cake = [NSString stringWithFormat:@\"使用%@，做好了：🎂🍞🍞🍰🍰🍰\",flour]; return cake; } RN端调用： //首先工具类里先引入 export const { showInfo,patCake } = NativeModules.RNInterractModule; //具体页面使用 patCake('1斤面粉', (cake) => alert(cake), (error) => alert('出错了' + error.message))} /> 调用效果： 1.4.4 使用Promise回调 Native端提供方法 RCT_EXPORT_METHOD(callNameTointroduction:(NSString *)name resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock) reject){ __weak __typeof(self)weakSelf = self; dispatch_sync(dispatch_get_main_queue(), ^{ if ([name isKindOfClass:NSString.class]) { resolve([weakSelf introduction:name]); }else{ NSError *error = [NSError errorWithDomain:@\"com.RNTest\" code:-1 userInfo:@{@\"message\":@\"类型不匹配\"}]; reject(@\"class_error\",@\"Needs NSString Class\",error); } }); } - (NSString *)introduction:(NSString *)name{ return [NSString stringWithFormat:@\"我的名字叫%@，今年18岁，喜欢运动、听歌...\",name]; } RN端调用： //首先工具类里先引入 export const { showInfo,patCake, callNameTointroduction} = NativeModules.RNInterractModule; //具体页面使用 { try { let introduction = await callNameTointroduction('小明'); showInfo(introduction); } catch (e) { alert(e.message); } } } /> 调用效果： 1.5 Native端发送通知到RN Native端继承RCTEventEmitter,实现发送RN通知类： RNNotificationManager.h #import #import #import NS_ASSUME_NONNULL_BEGIN @interface RNNotificationManager : RCTEventEmitter + (instancetype)sharedManager; @end NS_ASSUME_NONNULL_END RNNotificationManager.m #import \"RNNotificationManager.h\" @implementation RNNotificationManager { BOOL hasListeners; } + (instancetype)sharedManager{ static RNNotificationManager *manager; static dispatch_once_t onceToken; dispatch_once(&onceToken,^{ manager = [[self alloc] init]; }); return manager; } - (instancetype)init{ self = [super init]; if (self) { NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; [center removeObserver:self]; [center addObserver:self selector:@selector(handleEventNotification:) name:@\"kRNNotification_Login\" object:nil]; [center addObserver:self selector:@selector(handleEventNotification:) name:@\"kRNNotification_Logout\" object:nil]; }; return self; } RCT_EXPORT_MODULE() - (NSArray *)supportedEvents{ return @[ @\"kRNNotification_Login\", @\"kRNNotification_Logout\" ]; } //优化无监听处理的事件 //在添加第一个监听函数时触发 - (void)startObserving{ //setup any upstream listenerse or background tasks as necessary hasListeners = YES; NSLog(@\"----------->startObserving\"); } //will be called when this mdules's last listener is removed,or on dealloc. - (void)stopObserving{ //remove upstream listeners,stop unnecessary background tasks. hasListeners = NO; NSLog(@\"----------->stopObserving\"); } + (BOOL)requiresMainQueueSetup{ return YES; } - (void)handleEventNotification:(NSNotification *)notification{ if (!hasListeners) { return; } NSString *name = notification.name; NSLog(@\"通知名字-------->%@\",name); [self sendEventWithName:name body:notification.userInfo]; } @end RN端注册监听： //utils工具类中导出 export const NativeEmitterModuleIOS = new NativeEventEmitter(NativeModules.RNNotificationManager); //具体页面使用 import { NativeEmitterModuleIOS } from \"../utils\"; export default class ActivityScene extends Component { constructor(props) { super(props); this.subscription = null; this.state = { loginInfo: '当前未登录', }; } updateLoginInfoText = (reminder) => { this.setState({loginInfo: reminder.message}) }; //添加监听 componentWillMount() { this.subscription = NativeEmitterModuleIOS.addListener('kRNNotification_Login', this.updateLoginInfoText); } //移除监听 componentWillUnmount() { console.log('ActivityScene--------->', '移除通知'); this.subscription.remove(); } render() { return ( pushNative(RNEmitter)} /> {this.state.loginInfo} ); } } 效果展示： 1.6 完整Demo（包含iOS & Android) RN-NativeTest Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:13:50 "},"content/ReactNative/ReactNative与Android的交互.html":{"url":"content/ReactNative/ReactNative与Android的交互.html","title":"ReactNative与Android的交互","keywords":"","body":"ReactNative与Android的交互 1 RN调用Native方法 1、创建交互类Module，继承ReactContextBaseJavaModule； 2、创建package，实现ReactPackage的方法，添加步骤1创建的交互类Module到package内； 3、添加创建的自定义package到ReactNativeHost中的getPackages方法中，向ReactNative注册原生模块； 1.1 导出Native端的showInfo提示方法 Native端导出 public class RNInterractModule extends ReactContextBaseJavaModule { private ReactContext mReactContext; public RNInterractModule(ReactApplicationContext reactContext) { super(reactContext); this.mReactContext = reactContext; } //导出的模块名字 @Override public String getName() { return \"RNInterractModule\"; } //==============1、提示============== @ReactMethod public void showInfo(String info){ Toast.makeText(getReactApplicationContext(),info,Toast.LENGTH_SHORT).show(); } } 添加Module到自定义package： public class RNInterractPackage implements ReactPackage{ @Override public List createNativeModules(ReactApplicationContext reactContext) { List modules = new ArrayList<>(); modules.add(new RNInterractModule(reactContext)); return modules; } @Override public List createViewManagers(ReactApplicationContext reactContext) { return Collections.emptyList(); } } 再添加package（此处展示完整的MainApplication方法，重写getPackages()方法中添加） public class MainApplication extends Application implements ReactApplication{ @Override public ReactNativeHost getReactNativeHost() { return reactNativeHost; } private ReactNativeHost reactNativeHost = new ReactNativeHost(this) { @Override public boolean getUseDeveloperSupport() { return true; } @Override protected List getPackages() { return Arrays.asList( new MainReactPackage(), new RNInterractPackage() ); } @Override protected String getJSMainModuleName() { return \"index\"; } }; } 1.2 RN端调用导出的showInfo方法： 我们在RN端把Native的方法通过一个共同的utils工具类引入，如下 import { NativeModules } from 'react-native'; //导出Native端的方法 export const { showInfo} = NativeModules.RNInterractModule; 具体的RN页面使用时： import { showInfo } from \"../utils\"; //通过Button点击事件触发 showInfo('我是原生端的提示！')} /> 调用效果： 1.3 RN回调Native 我们提供一个例子来模拟：目前的需求是做面包，RN端能提供面粉，但是不会做，Native端是有做面包的功能；所以我们需要先把面粉，传给Native端，Native加工好面包之后，再通过回调回传给RN端。 Native端提供方法 // 比如调用原生的方法处理图片、视频之类的，处理完成之后再把结果回传到RN页面里去 //TODO: 请务必注意 callback 并非在对应的原生函数返回后立即被执行——注意跨语言通讯是异步的，这个执行过程会通过消息循环来进行。 @ReactMethod public void patCake(String flour, Callback successCallback,Callback errorCallback){ try{ //模拟异常，走reject if (!flour.getClass().equals(String.class)){ throw new Exception(\"出错了，参数类型不匹配\"); } successCallback.invoke(patCakeUse(flour)); }catch (Exception e){ errorCallback.invoke(e.getMessage()); } } //使用RN端传递的参数字符串：\"\"，调用Native端的做面包方法，加工成面包，再回传给RN private String patCakeUse(String flour){ String cake = String.format(\"使用%s，做好了:\\uD83C\\uDF82\\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF70\\uD83C\\uDF70\\uD83C\\uDF70\",flour); return cake; } RN端调用： //首先工具类里先引入 export const { showInfo,patCake } = NativeModules.RNInterractModule; //具体页面使用 patCake('1斤面粉', (cake) => alert(cake), (error) => alert('出错了' + error.message))} /> 调用效果： 1.4 使用Promise回调 Native端提供方法 @ReactMethod public void callNameTointroduction(String name, Promise promise){ try{ //模拟异常，走reject if (!name.getClass().equals(String.class)){ throw new Exception(\"出错了，参数类型不匹配\"); } promise.resolve(introduction(name)); }catch (Exception e){ promise.reject(e); } } private String introduction(String name){ return String.format(\"我的名字叫%s，今年18岁，喜欢运动、听歌...\",name); } RN端调用： //首先工具类里先引入 export const { showInfo,patCake, callNameTointroduction} = NativeModules.RNInterractModule; //具体页面使用 { try { let introduction = await callNameTointroduction('小明'); showInfo(introduction); } catch (e) { alert(e.message); } } } /> 调用效果： 2 Native发送通知到RN 实现自定义的发送RN消息类RNNotificationManager public class RNNotificationManager { //定义上下文 public static ReactContext mContext; //发送事件到RN端 public static void sendRNEvent(String eventName, @Nullable WritableMap params){ mContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(eventName,params); } } 我们使用静态成员变量、方法，mContext在自定义的RNInterractModule为其赋值： public class RNInterractModule extends ReactContextBaseJavaModule { private ReactContext mReactContext; public RNInterractModule(ReactApplicationContext reactContext) { super(reactContext); this.mReactContext = reactContext; //赋值 RNNotificationManager.mContext = reactContext; } } 然后就可以在需要给RN发送消息的地方调用： button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { WritableMap params = Arguments.createMap(); params.putString(\"message\",\"登录成功\"); RNNotificationManager.sendRNEvent(\"kRNNotification_Login\",params); } }); RN端接收消息： //添加监听 componentWillMount() { this.subscription = DeviceEventEmitter.addListener('kRNNotification_Login',this.updateLoginInfoText) } //移除监听 componentWillUnmount() { console.log('ActivityScene--------->', '移除通知'); this.subscription.remove(); } 调用展示： 3 Native向RN自定义传参 在继承ReactActivity的RN入口Activity中，自定义CustomDelegate（继承ReactActivityDelegate）； 然后重写CustomDelegate的getLaunchOptions()方法，此处的Bundle即为要传递的参数Bundle； 再重写RN入口Activity的createReactActivityDelegate()方法，返回CustomDelegate实例； RN端参数接收通过入口页面的this.props获取，具体可参考demo 示例： public class ReactNativeActivity extends ReactActivity { private String strData; @Override protected void onCreate(Bundle savedInstanceState) { Intent intent = getIntent(); if (intent != null){ strData = intent.getStringExtra(\"msgKey\"); } super.onCreate(savedInstanceState); } @Nullable @Override protected String getMainComponentName() { return \"RNTest\"; } @Override protected ReactActivityDelegate createReactActivityDelegate() { return new CustomDelegate(this,getMainComponentName()); } //自定义ReactDelegate class CustomDelegate extends ReactActivityDelegate { private CustomDelegate(Activity activity, @Nullable String mainComponentName) { super(activity, mainComponentName); } @Nullable @Override protected Bundle getLaunchOptions() { Bundle bundle = new Bundle(); bundle.putString(\"msg\",strData); return bundle; } } } 4 完整Demo（包含iOS & Android) RN-NativeTest Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:13:33 "},"content/ReactNative/ReactNative踩坑记录.html":{"url":"content/ReactNative/ReactNative踩坑记录.html","title":"ReactNative踩坑记录","keywords":"","body":"ReactNative踩坑记录 1、The SDK Build Tools revision (23.0.1) is too low for project ':react-native-extra-dimensions-android'. Minimum required is 25.0.0 解决：在node_modules/react-native-extra-dimensions-android/android，修改build.gradle（其他库类似问题，可参考解决）： apply plugin: 'com.android.library' android { compileSdkVersion 26 buildToolsVersion \"26.0.3\" defaultConfig { minSdkVersion 16 targetSdkVersion 26 versionCode 1 versionName \"1.0\" ndk { abiFilters \"armeabi-v7a\", \"x86\" } } } dependencies { compile 'com.facebook.react:react-native:+' } 2、undefined is not an object (evaluating 'NativeModules.ExtraDimensions[dim]') 解决：执行react-native link 某已安装的具体库名 注意一些老的教程和文档可能会提到rnpm link命令，此命令已过期不再使用 3、NetInfo's BUG issue：iOS: NetInfo.isConnected returns always false fix？ fix RCTNetInfo first time connection status 解决：（曲线救国） //设备是否联网 if (Platform.OS === 'ios') { NetInfo.isConnected.addEventListener('connectionChange', (isConnected) => { console.log('network：',isConnected ? 'online' : 'offline'); } ); } else { NetInfo.isConnected.fetch().then(isConnected => { console.log('network：',isConnected ? 'online' : 'offline'); }); } 4、 Unable to connect with remote debugger Dev Tools launch to 10.0.2.2 instead of localhost !--![](https://ws1.sinaimg.cn/large/72ebc0edgy1g1vddukjk0j20co0midhf.jpg)-- 解决： In my case the issue was that the emulator was making a request to: http://10.0.2.2:8081/debugger-ui instead of: http://localhost:8081/debugger-ui > Press Cmd + M on emulator screen Go to Dev settings > Debug server host & port for device Set localhost:8081 Rerun the android app: react-native run-android 5、 Required dispatch_sync to load constants for xxxxx. This may lead to deadlocks 解决：模拟器接入浏览器调试才会出现，如果不适用浏览器调试，就不会弹出这个警告。 6、React Native之Text中文字如何居中 解决： 方案一 设置 lineHeight, 如果 Text 的 height 为 100，设置 lineHeight 为 100, 文本就垂直居中了。（完美） 方案二 给 Text 设置 padding，这个就需要计算了，比如 Text 高度是 100， fontSize 是 20，那可以设置 paddingTop 为 40（fontSize 为 20，默认是 20 高度） 方案三 在 Text 外部在嵌套一个 View， 改变 View 的高度，在来调整 Text 的布局，这种方案麻烦，多出一个层级，会影响性能的。 总结 如果 lineHeight 在 android 上面不起作用（可能是bug）可以使用下面总结的方案： import {StyleSheet,Platform} from 'react-native'; TextStyle:{ height:36, width:100, textAlign:'center', alignItems:'center', justifyContent:'center', textAlignVertical:'center', ...Platform.select({ ios:{ lineHeight:36, }, android:{ } }), } 6、 react-navigation：undefined is not an object (evaluating _this.props.navigation) 解决： //在static navigationOptions设置中 无法获取this.props，导致错误 //正确方式 static navigationOptions = ({navigation}) => ({ headerTitle: '全部分类', headerRight: ( navigation.push('Search')} > ) }); 7、 Android P ：Could not connect to development server. Google表示，为保证用户数据和设备的安全，针对下一代 Android 系统(Android P) 的应用程序，将要求默认使用加密连接，这意味着 Android P 将禁止 App 使用所有未加密的连接，因此运行 Android P 系统的安卓设备无论是接收或者发送流量，未来都不能明码传输，需要使用下一代(Transport Layer Security)传输层安全协议，而 Android Nougat 和 Oreo 则不受影响。 因此在Android P 使用HttpUrlConnection进行http请求会出现以下异常 W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted 使用OKHttp请求则出现 java.net.UnknownServiceException: CLEARTEXT communication ** not permitted by network security policy 解决： 在 res 下新增一个 xml 目录，然后创建一个名为：network_security_config.xml 文件（名字自定） ，内容如下，大概意思就是允许开启http请求 然后在APP的AndroidManifest.xml文件下的application标签增加以下属性 8、 ReactNative mutex.h中config.h报错 ❌ 解决： 终端进入node_modules文件夹所在目录，输入下列命令行， cd node_modules/react-native/third-party/glog-0.3.4 ../../scripts/ios-configure-glog.sh Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:12:24 "},"content/ReactNative/ReactNative触摸事件.html":{"url":"content/ReactNative/ReactNative触摸事件.html","title":"ReactNative触摸事件","keywords":"","body":"ReactNative触摸事件 1、基本的触摸组件 Text Button Touchable系列组件 TouchableHighlight TouchableNativeFeedback TouchableOpacity TouchableWithoutFeedback 这些组件都支持onPressIn、onPressOut、onPress、onLongPress方法。 使用TouchableOpacity示例： console.log(\"onPressIn\")} onPressOut={() => console.log(\"onPressOut\")} onPress={() => console.log(\"onPress\")} onLongPress={() => console.log(\"onLongPress\")} > Touch*手势的区别： 1、TouchableHighlight，除了给内部元素增加绑定事件之外，还负责给内部元素增加点击的效果； 2、TouchableNativeFeedback只能用在安卓平台上，它可以针对点击在点击区域中显示不同的效果，例如安卓系统中的点击波纹效果； 3、TouchableOpacity这个组件用来给为内部元素在点击时添加透明度； 4、TouchableWithoutFeedback这个组件只响应touch手势，不增加点击态，不推荐使用。 2、手势响应系统 2.1单组件触摸事件处理 RN的组件默认不进行处理触摸事件，但是我们可以将一个普通的View组件变成一个能响应手势操作的responder，只需要在props上设置如下方法： View.props.onStartShouldSetResponder View.props.onMoveShouldSetResponder View.props.onResponderGrant View.props.onResponderReject View.props.onResponderStart View.props.onResponderMove View.props.onResponderEnd View.props.onResponderRelease View.props.onResponderTerminationRequest View.props.onResponderTerminate React Native事件响应的基本步骤如下： 1、如果组件要进行触摸事件处理，首先要申请成为事件响应者，通过如下两个属性询问组件是否成为响应者： View.props.onStartShouldSetResponder: (evt) => true，在触摸开始的时候（TouchDown），ReactNative会先调用此函数，询问组件是否需要成为事件的响应者； View.props.onMoveShouldSetResponder: (evt) => true，如果View不是响应者，那么在每一个触摸点开始移动； 2、因为同一时刻，只能有一个事件处理响应者，所以并不是每个组件都能申请成功，RN通过如下两个回调告知申请结果： View.props.onResponderGrant: (evt) => {}：表示申请成功，组件成为了事件处理响应者，这时组件就开始接收后序的触摸事件输入。一般情况下，这时开始，组件进入了激活状态，并进行一些事件处理或者手势识别的初始化。 View.props.onResponderReject: (evt) => {}：表示申请失败了，这意味者其他组件正在进行事件处理，并且它不想放弃事件处理，所以你的申请被拒绝了，后续输入事件不会传递给本组件进行处理。 3、如果组件申请成为了响应者，会执行如下回调方法： View.props.onResponderStart: (evt) => {}：表示手指按下时，成功申请为事件响应者的回调； View.props.onResponderMove: (evt) => {}：表示触摸手指移动的事件，这个回调可能非常频繁，所以这个回调函数的内容需要尽量简单； View.props.onResponderEnd: (evt) => {}：表示组件结束事件响应。 View.props.onResponderRelease: (evt) => {}：表示触摸完成（touchUp）的时候的回调，表示用户完成了本次的触摸交互，这里应该完成手势识别的处理，这以后，组件不再是事件响应者，组件取消激活。 4、当组件处于响应者期间，并且其他组件也在申请触摸事件处理时，RN会询问是否可以释放响应让给其他组件： View.props.onResponderTerminationRequest: (evt) => bool 5、最终释放响应者的角色后，回调onResponderTerminate，通知组件事件响应处理被终止： 可能是由于其他 View 通过onResponderTerminationRequest请求的，也可能是由操作系统强制夺权（比如 iOS 上的控制中心或是通知中心） View.props.onResponderTerminate: (evt) => {} 示例代码： import React, {Component} from 'react'; import { StyleSheet, View, Button, Text } from 'react-native'; export default class GestureScreen extends Component { constructor(props) { super(props); this.state = { backgroundColor: 'blue' }; this.gestureHandlers = { onStartShouldSetResponder: () => true, onMoveShouldSetResponder: () => true, onResponderStart:() => { console.log('onResponderStart') }, onResponderGrant: () => { console.log('onResponderGrant'); this.setState({backgroundColor: 'green'}) }, onResponderMove: () => { console.log('onResponderMove') }, onResponderEnd:() => { console.log('onResponderEnd') }, onResponderRelease: () => { console.log('onResponderRelease') this.setState({backgroundColor: 'blue'}) }, onResponderTerminationRequest: () => { console.log('onResponderTerminationRequest'); return true; }, onResponderTerminate: (evt) => { console.log('onResponderTerminate') } }; } render() { return ( View 1 ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor:'rgb(236,236,236)' }, gesview:{ width:160, height:80, borderRadius:20, borderColor:'red', borderWidth:2, alignItems:'center', justifyContent:'center', }, text:{ color:'white', fontSize:20, fontWeight:'bold' } }); 执行这段代码，responderGrant响应，中间绿色的View变为蓝色,responderRelease响应，重新变为绿色; 点击一次View，然后离开屏幕，调用顺序： 1、onResponderGrant 2、onResponderStart 3、onResponderEnd 4、onResponderRelease 2.2嵌套组件触摸事件处理 如果父View A中嵌套有一个子组件View B， 正常的情况，当用户触摸View B时，子组件会显示：B 子组件 被点击，父View则不会有反应；当点击View A时，View A会显示：A 组件 被点击，子View B没有反应，以保证视图都能够正常处理触摸事件。 示例 import React, {Component} from 'react'; import { StyleSheet, View, Button, Text } from 'react-native'; export default class GestureScreen extends Component { constructor(props) { super(props); this.state = { text1: 'A 父组件', text2:'B 子组件' }; this.gestureHandlers = { onStartShouldSetResponder: () => true, onMoveShouldSetResponder: () => true, onResponderStart: () => { console.log('onResponderStart') }, onResponderGrant: () => { console.log('onResponderGrant'); this.setState({text1: 'A 父组件 被点击'}) }, onResponderMove: () => { console.log('onResponderMove') }, onResponderEnd: () => { console.log('onResponderEnd') }, onResponderRelease: () => { console.log('onResponderRelease') this.setState({text1:'A 父组件'}) }, }; this.gestureHandlers2 = { onStartShouldSetResponder: () => true, onMoveShouldSetResponder: () => true, onResponderStart: () => { console.log('onResponderStart---->2') }, onResponderGrant: () => { console.log('onResponderGrant---->2'); this.setState({text2: 'B 子组件 被点击'}) }, onResponderMove: () => { console.log('onResponderMove---->2') }, onResponderEnd: () => { console.log('onResponderEnd---->2') }, onResponderRelease: () => { console.log('onResponderRelease---->2') this.setState({text2: 'B 子组件'}) }, }; } render() { return ( {this.state.text1} {this.state.text2} ); } } const styles = StyleSheet.create({ container: { flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: 'rgb(236,236,236)' }, gesview: { width: 200, height: 200, backgroundColor:'#B34D76', }, text: { color: 'white', fontSize: 20, fontWeight: 'bold' }, sonview: { width:100, height:100, backgroundColor:'#33AECC', alignSelf:'center', marginTop:20, } }); 但是，在 RN 中，默认情况下使用冒泡机制，响应最深的组件最先开始响应。所以当多个 View 同时在*ShouldSetResponder中返回 true 时，最底层的 View 将最先响应。 RN 提供了一个劫持机制，在触摸事件往下传递的时候，先询问父组件是否需要劫持，不给子组件传递事件，也就是如下两个回调： View.props.onStartShouldSetResponderCapture: (evt) => true View.props.onMoveShouldSetResponderCapture: (evt) => true 我们设置View A的以上两个属性为true时，效果： 可见点击B子View时，A父View显示被点击，点击A View，依然是A被点击；B的事件被父View拦截并处理，并且不再继续传递。 2.3事件数据结构 触摸事件处理的回调都有一个 evt 参数，包含一个触摸事件数据 nativeEvent。nativeEvent 的详细内容如下 changedTouches - 在上一次事件之后，所有发生变化的触摸事件的数组集合（即上一次事件后，所有移动过的触摸点） identifier - 触摸点的 ID locationX - 触摸点相对于当前元素的横坐标 locationY - 触摸点相对于当前元素的纵坐标 pageX - 触摸点相对于根元素的横坐标 pageY - 触摸点相对于根元素的纵坐标 target - 触摸点所在的元素 ID timestamp - 触摸事件的时间戳，可用于移动速度的计算 touches - 当前屏幕上的所有触摸点的集合 3、PanResponder RN提供了内置的手势识别库PanResponder，它封装了上面的事件回调函数，对触摸事件数据进行加工，完成滑动手势识别： PanResponder的每个方法，除了第一个evt参数之外，还可以使用第二个参数gestureState，gestureState是一个对象，包含手势进行过程中更多的信息 3.1 一个gestureState对象有如下的字段： stateID - 触摸状态的 ID。在屏幕上有至少一个触摸点的情况下，这个 ID 会一直有效。 moveX - 最近一次移动时的屏幕横坐标 moveY - 最近一次移动时的屏幕纵坐标 x0 - 当响应器产生时的屏幕坐标 y0 - 当响应器产生时的屏幕坐标 dx - 从触摸操作开始时的累计横向路程 dy - 从触摸操作开始时的累计纵向路程 vx - 当前的横向移动速度 vy - 当前的纵向移动速度 numberActiveTouches - 当前在屏幕上的有效触摸点的数量 3.2 PanResponder.create()方法中，可配置的属性： onMoveShouldSetPanResponder: (e, gestureState) => {...} onMoveShouldSetPanResponderCapture: (e, gestureState) => {...} onStartShouldSetPanResponder: (e, gestureState) => {...} onStartShouldSetPanResponderCapture: (e, gestureState) => {...} onPanResponderReject: (e, gestureState) => {...} onPanResponderGrant: (e, gestureState) => {...} onPanResponderStart: (e, gestureState) => {...} onPanResponderEnd: (e, gestureState) => {...} onPanResponderRelease: (e, gestureState) => {...} onPanResponderMove: (e, gestureState) => {...} onPanResponderTerminate: (e, gestureState) => {...} onPanResponderTerminationRequest: (e, gestureState) => {...} onShouldBlockNativeResponder: (e, gestureState) => {...} 3.3 使用PanResponder,简单实现一个拖拽视图： import React, {Component} from 'react'; import { StyleSheet, View, PanResponder } from 'react-native'; export default class GestureScreen extends Component { constructor(props) { super(props); this.state = { top:0, left:0 }; this.panResponder = PanResponder.create({ onStartShouldSetPanResponder: () => true, onMoveShouldSetPanResponder: ()=> true, onPanResponderGrant: ()=>{ this.top = this.state.top; this.left = this.state.left; }, onPanResponderMove: (evt,gestureState)=>{ this.setState({ top: this.top+gestureState.dy, left: this.left+gestureState.dx }) }, onPanResponderRelease: (evt,gestureState)=>{ this.setState({ top: this.top+gestureState.dy, left: this.left+gestureState.dx })} }) } render() { return ( ); } } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, dragview: { width: 100, height: 100, backgroundColor:'red', borderRadius:50, } }); 4、总结 通过上面的介绍，可以看到 RN 中提供了类似 Native 平台的事件处理机制，所以也可以实现各种的触摸事件处理，甚至也可以实现复杂的手势识别。 另外需要注意，因为 RN 的异步通信和执行机制，前面描述的所有回调函数都是在 JS 线程中，并不是 Native 的 UI 线程，而 Native 平台的 Touch 事件都是在 UI 线程中。所以在 JS 中通过 Touch 或者手势实现动画，可能会延迟的问题。 本文是浅析，介绍比较简单。可能存在诸多错误和不足之处，欢迎交流。 参考： 手势响应系统_官方文档 PanResponder_官方文档 “指尖上的魔法” -- 谈谈React-Native中的手势 ReactNative 中常见的可触控方法 React Native 触摸事件处理详解 Copyright © BulldogX all right reserved，powered by Gitbook修订时间： 2019-12-13 16:13:02 "}}